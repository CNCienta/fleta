package pof

import (
	"bytes"
	"encoding/json"

	"github.com/fletaio/fleta/common"
	"github.com/fletaio/fleta/common/amount"
	"github.com/fletaio/fleta/core/types"
)

// CreateAlpha is a consensus.CreateAlpha
// It is used to make formulation account
type CreateAlpha struct {
	Seq_    uint64
	From_   common.Address
	Name    string
	KeyHash common.PublicHash
}

// IsUTXO returns false
func (tx *CreateAlpha) IsUTXO() bool {
	return false
}

// From returns the creator of the transaction
func (tx *CreateAlpha) From() common.Address {
	return tx.From_
}

// Seq returns the sequence of the transaction
func (tx *CreateAlpha) Seq() uint64 {
	return tx.Seq_
}

func (tx *CreateAlpha) Validate(loader types.Loader, signers []common.PublicHash) error {
	if len(tx.Name) < 8 || len(tx.Name) > 16 {
		return ErrInvalidAccountName
	}

	if tx.Seq() <= loader.Seq(tx.From()) {
		return ErrInvalidSequence
	}

	fromAcc, err := loader.Account(tx.From())
	if err != nil {
		return err
	}
	if err := fromAcc.Validate(loader, signers); err != nil {
		return err
	}
	return nil
}

func (tx *CreateAlpha) Execute(ctx *types.Context, Fee *amount.Amount, t types.Transaction, coord *common.Coordinate) (ret interface{}, rerr error) {
	if len(tx.Name) < 8 || len(tx.Name) > 16 {
		return nil, ErrInvalidAccountName
	}

	policy, has := gFormulationPolicyMap[ctx.ChainCoord().ID()]
	if !has {
		return nil, ErrNotExistFormulationPolicy
	}
	if ctx.TargetHeight() < policy.FormulatorCreationLimitHeight {
		return nil, ErrFormulatorCreationLimited
	}

	sn := ctx.Snapshot()
	defer ctx.Revert(sn)

	if tx.Seq() != ctx.Seq(tx.From())+1 {
		return nil, ErrInvalidSequence
	}
	ctx.AddSeq(tx.From())

	fromAcc, err := ctx.Account(tx.From())
	if err != nil {
		return nil, err
	}
	if err := fromAcc.SubBalance(Fee); err != nil {
		return nil, err
	}
	if err := fromAcc.SubBalance(policy.AlphaCreationAmount); err != nil {
		return nil, err
	}

	addr := common.NewAddress(coord, 0)
	if is, err := ctx.IsExistAccount(addr); err != nil {
		return nil, err
	} else if is {
		return nil, ErrExistAddress
	} else if isn, err := ctx.IsExistAccountName(tx.Name); err != nil {
		return nil, err
	} else if isn {
		return nil, ErrExistAccountName
	} else {
		a, err := ctx.Accounter().NewByTypeName("consensus.FormulationAccount")
		if err != nil {
			return nil, err
		}
		acc := a.(*FormulationAccount)
		acc.Address_ = addr
		acc.Name_ = tx.Name
		acc.FormulationType = AlphaFormulatorType
		acc.KeyHash = tx.KeyHash
		acc.Amount = policy.AlphaCreationAmount
		ctx.CreateAccount(acc)
	}
	ctx.Commit(sn)
	return nil, nil
}

// MarshalJSON is a marshaler function
func (tx *CreateAlpha) MarshalJSON() ([]byte, error) {
	var buffer bytes.Buffer
	buffer.WriteString(`{`)
	buffer.WriteString(`"type":`)
	if bs, err := json.Marshal(tx.Type_); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`,`)
	buffer.WriteString(`"timestamp":`)
	if bs, err := json.Marshal(tx.Timestamp_); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`,`)
	buffer.WriteString(`"seq":`)
	if bs, err := json.Marshal(tx.Seq_); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`,`)
	buffer.WriteString(`"from":`)
	if bs, err := tx.From_.MarshalJSON(); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`,`)
	buffer.WriteString(`"name":`)
	if bs, err := json.Marshal(tx.Name); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`,`)
	buffer.WriteString(`"from":`)
	if bs, err := tx.KeyHash.MarshalJSON(); err != nil {
		return nil, err
	} else {
		buffer.Write(bs)
	}
	buffer.WriteString(`}`)
	return buffer.Bytes(), nil
}
